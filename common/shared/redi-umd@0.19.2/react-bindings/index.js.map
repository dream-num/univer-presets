{"version":3,"file":"index.js","names":["globalObject: any","props: React.PropsWithChildren<{ dependencies: Dependency[] }>","context: { injector: Injector | null }","childInjector: Injector","Injector","Comp: React.ComponentType<P>","injector: Injector","props: P","dependencies: Dependency[]","RediError","component: React.Component<T>","id: DependencyIdentifier<T>","quantity?: Quantity","lookUp?: LookUp","thisComponent: React.Component<T>","Quantity","RediError","id: DependencyIdentifier<T>","quantityOrLookUp?: Quantity | LookUp","lookUp?: LookUp","depValue$: Observable<T>","defaultValue?: T","firstValue: T | undefined","BehaviorSubject","val: T","o: ObservableOrFn<T>","observable: Nullable<ObservableOrFn<T>>","defaultValue?: undefined","shouldHaveSyncValue?: true","deps?: any[]","RediError","innerDefaultValue: T | undefined","subscription: Subscription | null","update$: Observable<void>","props: { initialState?: T; children: ReactNode }"],"sources":["../../../src/react-bindings/reactContext.tsx","../../../src/react-bindings/reactComponent.tsx","../../../src/react-bindings/reactDecorators.ts","../../../src/react-bindings/reactHooks.tsx","../../../src/react-bindings/reactRx.tsx"],"sourcesContent":["/* eslint-disable node/prefer-global/process */\n\nimport type { Injector } from '@wendellhu/redi';\nimport { createContext } from 'react';\n\nconst __REDI_CONTEXT_LOCK__ = 'REDI_CONTEXT_LOCK';\nconst isNode =\n  typeof process !== 'undefined' &&\n  process.versions != null &&\n  process.versions.node != null;\n\nconst globalObject: any =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof window !== 'undefined' && window) ||\n  // eslint-disable-next-line no-restricted-globals\n  (typeof global !== 'undefined' && global);\n\nif (!globalObject[__REDI_CONTEXT_LOCK__]) {\n  globalObject[__REDI_CONTEXT_LOCK__] = true;\n} else if (!isNode) {\n  console.error(\n    '[redi]: \"RediContext\" is already created. You may import \"RediContext\" from different paths. Use \"import { RediContext } from \\'@wendellhu/redi/react-bindings\\'; instead.\"',\n  );\n}\n\nexport interface IRediContext {\n  injector: Injector | null;\n}\n\nexport const RediContext = createContext<IRediContext>({\n  injector: null,\n});\nRediContext.displayName = 'RediContext';\n\nexport const RediProvider = RediContext.Provider;\nexport const RediConsumer = RediContext.Consumer;\n","import type { Dependency } from '@wendellhu/redi';\nimport { Injector } from '@wendellhu/redi';\nimport React, { useEffect, useRef } from 'react';\nimport { RediConsumer, RediProvider } from './reactContext';\n\nfunction RediInjector(\n  props: React.PropsWithChildren<{ dependencies: Dependency[] }>,\n) {\n  const { children, dependencies } = props;\n  const childInjectorRef = useRef<Injector | null>(null);\n\n  // dispose the injector when the container Injector unmounts\n  useEffect(() => () => childInjectorRef.current?.dispose(), []);\n\n  return (\n    <RediConsumer>\n      {(context: { injector: Injector | null }) => {\n        let childInjector: Injector;\n\n        if (childInjectorRef.current) {\n          childInjector = childInjectorRef.current;\n        } else {\n          childInjector = context.injector\n            ? context.injector.createChild(dependencies)\n            : new Injector(dependencies);\n\n          childInjectorRef.current = childInjector;\n        }\n\n        return (\n          <RediProvider value={{ injector: childInjector }}>\n            {children}\n          </RediProvider>\n        );\n      }}\n    </RediConsumer>\n  );\n}\n\n/**\n * @param Comp\n * @param injector\n * @returns A component type that can be rendered.\n */\nexport function connectInjector<P>(\n  Comp: React.ComponentType<P>,\n  injector: Injector,\n): React.ComponentType<P> {\n  return function ComponentWithInjector(props: P) {\n    return (\n      <RediProvider value={{ injector }}>\n        <Comp {...(props as P & React.JSX.IntrinsicAttributes)} />\n      </RediProvider>\n    );\n  };\n}\n\nexport function connectDependencies<P>(\n  Comp: React.ComponentType<P>,\n  dependencies: Dependency[],\n): React.ComponentType<P> {\n  return function ComponentWithInjector(props: P) {\n    return (\n      <RediInjector dependencies={dependencies}>\n        <Comp {...(props as P & React.JSX.IntrinsicAttributes)} />\n      </RediInjector>\n    );\n  };\n}\n","import type { DependencyIdentifier, LookUp } from '@wendellhu/redi';\nimport type { IRediContext } from './reactContext';\nimport { Quantity, RediError } from '@wendellhu/redi';\n\nclass ClassComponentNotInRediContextError<T> extends RediError {\n  constructor(component: React.Component<T>) {\n    super(\n      `You should make \"RediContext\" as ${component.constructor.name}'s default context type. ` +\n      'If you want to use multiple context, please check this on React doc site. ' +\n      'https://reactjs.org/docs/context.html#classcontexttype',\n    );\n  }\n}\n\nexport function WithDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity?: Quantity,\n  lookUp?: LookUp,\n): any {\n  return function () {\n    return {\n      get(): T | T[] | null {\n        const thisComponent: React.Component<T> = this as any;\n\n        const context = thisComponent.context as IRediContext | null;\n        if (!context || !context.injector) {\n          throw new ClassComponentNotInRediContextError(thisComponent);\n        }\n\n        const injector = context.injector;\n        const thing = injector.get(id, quantity || Quantity.REQUIRED, lookUp);\n\n        return thing;\n      },\n    };\n  };\n}\n","import type {\n  DependencyIdentifier,\n  Injector,\n  LookUp,\n  Quantity,\n} from '@wendellhu/redi';\nimport { RediError } from '@wendellhu/redi';\nimport { useContext, useMemo } from 'react';\nimport { RediContext } from './reactContext';\n\nclass HooksNotInRediContextError extends RediError {\n  constructor() {\n    super('Using dependency injection outside of a RediContext.');\n  }\n}\n\nexport function useInjector(): Injector {\n  const injectionContext = useContext(RediContext);\n  if (!injectionContext.injector) {\n    throw new HooksNotInRediContextError();\n  }\n\n  return injectionContext.injector;\n}\n\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  lookUp?: LookUp,\n): T;\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity: Quantity.MANY,\n  lookUp?: LookUp,\n): T[];\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity: Quantity.OPTIONAL,\n  lookUp?: LookUp,\n): T | null;\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity: Quantity.REQUIRED,\n  lookUp?: LookUp,\n): T;\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity: Quantity,\n  lookUp?: LookUp,\n): T | T[] | null;\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantity?: Quantity,\n  lookUp?: LookUp,\n): T | T[] | null;\nexport function useDependency<T>(\n  id: DependencyIdentifier<T>,\n  quantityOrLookUp?: Quantity | LookUp,\n  lookUp?: LookUp,\n): T | T[] | null {\n  const injector = useInjector();\n  return useMemo(\n    () => injector.get<T>(id, quantityOrLookUp, lookUp),\n    [id, quantityOrLookUp, lookUp],\n  );\n}\n","import type { Context, JSX, ReactNode } from 'react';\nimport type { Observable, Subscription } from 'rxjs';\nimport { RediError } from '@wendellhu/redi';\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * unwrap an observable value, return it to the component for rendering, and\n * trigger re-render when value changes\n *\n * **IMPORTANT**. Parent and child components better not subscribe to the same\n * observable, otherwise unnecessary re-render would be triggered. Instead, the\n * top-most component should subscribe and pass value of the observable to\n * its offspring, by props or context. Please consider using `useDependencyContext` and\n * `useDependencyContextValue` in this case.\n *\n * @deprecated Please use `useObservable` instead.\n */\nexport function useDependencyValue<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T,\n): T | undefined {\n  const firstValue: T | undefined =\n    depValue$ instanceof BehaviorSubject && typeof defaultValue === 'undefined'\n      ? depValue$.getValue()\n      : defaultValue;\n  const [value, setValue] = useState(firstValue);\n\n  useEffect(() => {\n    const subscription = depValue$.subscribe((val: T) => setValue(val));\n    return () => subscription.unsubscribe();\n  }, [depValue$]);\n\n  return value;\n}\n\ntype ObservableOrFn<T> = Observable<T> | (() => Observable<T>);\ntype Nullable<T> = T | undefined | null;\n\nfunction unwrap<T>(o: ObservableOrFn<T>): Observable<T> {\n  if (typeof o === 'function') {\n    return o();\n  }\n\n  return o;\n}\n\nexport function useObservable<T>(observable: Nullable<ObservableOrFn<T>>): T;\nexport function useObservable<T>(\n  observable: Nullable<ObservableOrFn<T>>,\n  defaultValue: T,\n): T;\nexport function useObservable<T>(\n  observable: Nullable<ObservableOrFn<T>>,\n  defaultValue: undefined,\n  shouldHaveSyncValue: true,\n  deps?: any[],\n): T;\nexport function useObservable<T>(\n  observable: Nullable<ObservableOrFn<T>>,\n  defaultValue?: undefined,\n  shouldHaveSyncValue?: true,\n  deps?: any[],\n): T | undefined;\n/**\n * Subscribe to an observable and return its value. The component will re-render when the observable emits a new value.\n *\n * @param observable An observable or a function that returns an observable\n * @param defaultValue The default value of the observable. It the `observable` can omit an initial value, this value will be neglected.\n * @param shouldHaveSyncValue If the observable should have a sync value. If it does not have a sync value, an error will be thrown.\n * @param deps A dependency array to decide if we should re-subscribe when the `observable` is a function.\n * @returns Value or null.\n */\nexport function useObservable<T>(\n  observable: Nullable<ObservableOrFn<T>>,\n  defaultValue?: undefined,\n  shouldHaveSyncValue?: true,\n  deps?: any[],\n): T | undefined {\n  if (typeof observable === 'function' && !deps) {\n    throw new RediError(\n      'Expected deps to be provided when observable is a function!',\n    );\n  }\n\n  const observableRef = useRef<Observable<T> | null>(null);\n  const initializedRef = useRef<boolean>(false);\n\n  const destObservable = useMemo(\n    () => observable,\n    [...(typeof deps !== 'undefined' ? deps : [observable])],\n  );\n\n  // This state is only for trigger React to re-render. We do not use `setValue` directly because it may cause\n  // memory leaking.\n  const [_, setRenderCounter] = useState<number>(0);\n\n  const valueRef = useRef<T | undefined>(\n    (() => {\n      let innerDefaultValue: T | undefined;\n      if (destObservable) {\n        const sub = unwrap(destObservable).subscribe((value) => {\n          initializedRef.current = true;\n          innerDefaultValue = value;\n        });\n\n        sub.unsubscribe();\n      }\n\n      return innerDefaultValue ?? defaultValue;\n    })(),\n  );\n\n  useEffect(() => {\n    let subscription: Subscription | null = null;\n    if (destObservable) {\n      observableRef.current = unwrap(destObservable);\n      subscription = observableRef.current.subscribe((value) => {\n        valueRef.current = value;\n        setRenderCounter((prev) => prev + 1);\n      });\n    }\n\n    return () => subscription?.unsubscribe();\n  }, [destObservable]);\n\n  if (shouldHaveSyncValue && !initializedRef.current) {\n    throw new Error(\n      'Expect `shouldHaveSyncValue` but not getting a sync value!',\n    );\n  }\n\n  return valueRef.current;\n}\n\n/**\n * subscribe to a signal that emits whenever data updates and re-render\n *\n * @param update$ a signal that the data the functional component depends has updated\n */\nexport function useUpdateBinder(update$: Observable<void>): void {\n  const [, dumpSet] = useState(0);\n\n  useEffect(() => {\n    const subscription = update$.subscribe(() => dumpSet((prev) => prev + 1));\n    return () => subscription.unsubscribe();\n  }, []);\n}\n\nconst DepValueMapProvider = new WeakMap<Observable<any>, Context<any>>();\n\n/**\n * subscribe to an observable value from a service, creating a context for it so\n * it child component won't have to subscribe again and cause unnecessary\n */\nexport function useDependencyContext<T>(\n  depValue$: Observable<T>,\n  defaultValue?: T,\n): {\n  Provider: (props: { initialState?: T; children: ReactNode }) => JSX.Element;\n  value: T | undefined;\n} {\n  const depRef = useRef<Observable<T> | undefined>(undefined);\n  const value = useObservable(depValue$, defaultValue);\n  const Context = useMemo(\n    () => createContext<T | undefined>(value),\n    [depValue$],\n  );\n  const Provider = useCallback(\n    (props: { initialState?: T; children: ReactNode }) => {\n      return (\n        <Context.Provider value={value}>{props.children}</Context.Provider>\n      );\n    },\n    [depValue$, value],\n  );\n\n  if (depRef.current !== depValue$) {\n    if (depRef.current) {\n      DepValueMapProvider.delete(depRef.current);\n    }\n\n    depRef.current = depValue$;\n    DepValueMapProvider.set(depValue$, Context);\n  }\n\n  return {\n    Provider,\n    value,\n  };\n}\n\nexport function useDependencyContextValue<T>(\n  depValue$: Observable<T>,\n): T | undefined {\n  const context = DepValueMapProvider.get(depValue$);\n\n  if (!context) {\n    throw new RediError(\n      `try to read context value but no ancestor component subscribed it.`,\n    );\n  }\n\n  return useContext(context);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAM,wBAAwB;AAC9B,MAAM,gBACG,YAAY,eACnB,QAAQ,YAAY,QACpB,QAAQ,SAAS,QAAQ;AAE3B,MAAMA,sBACI,eAAe,eAAe,qBAC9B,WAAW,eAAe,iBAE1B,WAAW,eAAe;AAEpC,KAAK,aAAa,uBAChB,cAAa,yBAAyB;UAC5B,OACV,SAAQ,MACN,kLACD;AAOH,MAAa,cAAc,yBAA4B,EACrD,UAAU,KACX,EAAC;AACF,YAAY,cAAc;AAE1B,MAAa,eAAe,YAAY;AACxC,MAAa,eAAe,YAAY;;;;AC9BxC,SAAS,aACPC,OACA;CACA,MAAM,EAAE,UAAU,cAAc,GAAG;CACnC,MAAM,mBAAmB,kBAAwB,KAAK;AAGtD,sBAAU,MAAM,MAAM,iBAAiB,SAAS,SAAS,EAAE,CAAE,EAAC;AAE9D,wBACE,2BAAC,0BACE,CAACC,YAA2C;EAC3C,IAAIC;AAEJ,MAAI,iBAAiB,QACnB,iBAAgB,iBAAiB;OAC5B;AACL,mBAAgB,QAAQ,WACpB,QAAQ,SAAS,YAAY,aAAa,GAC1C,IAAIC,0BAAS;AAEjB,oBAAiB,UAAU;EAC5B;AAED,yBACE,2BAAC;GAAa,OAAO,EAAE,UAAU,cAAe;GAC7C;IACY;CAElB,IACY;AAElB;;;;;;AAOD,SAAgB,gBACdC,MACAC,UACwB;AACxB,QAAO,SAAS,sBAAsBC,OAAU;AAC9C,yBACE,2BAAC;GAAa,OAAO,EAAE,SAAU;6BAC/B,2BAAC,QAAK,GAAK,QAA+C;IAC7C;CAElB;AACF;AAED,SAAgB,oBACdF,MACAG,cACwB;AACxB,QAAO,SAAS,sBAAsBD,OAAU;AAC9C,yBACE,2BAAC;GAA2B;6BAC1B,2BAAC,QAAK,GAAK,QAA+C;IAC7C;CAElB;AACF;;;;AChED,IAAM,sCAAN,cAAqDE,2BAAU;CAC7D,YAAYC,WAA+B;AACzC,QACE,CAAC,iCAAiC,EAAE,UAAU,YAAY,KAAK,yJAAyB,CAEhC,CACzD;CACF;AACF;AAED,SAAgB,eACdC,IACAC,UACAC,QACK;AACL,QAAO,WAAY;AACjB,SAAO,EACL,MAAsB;GACpB,MAAMC,gBAAoC;GAE1C,MAAM,UAAU,cAAc;AAC9B,QAAK,YAAY,QAAQ,SACvB,OAAM,IAAI,oCAAoC;GAGhD,MAAM,WAAW,QAAQ;GACzB,MAAM,QAAQ,SAAS,IAAI,IAAI,YAAYC,0BAAS,UAAU,OAAO;AAErE,UAAO;EACR,EACF;CACF;AACF;;;;AC1BD,IAAM,6BAAN,cAAyCC,2BAAU;CACjD,cAAc;AACZ,QAAM,uDAAuD;CAC9D;AACF;AAED,SAAgB,cAAwB;CACtC,MAAM,mBAAmB,sBAAW,YAAY;AAChD,MAAK,iBAAiB,SACpB,OAAM,IAAI;AAGZ,QAAO,iBAAiB;AACzB;AA+BD,SAAgB,cACdC,IACAC,kBACAC,QACgB;CAChB,MAAM,WAAW,aAAa;AAC9B,QAAO,mBACL,MAAM,SAAS,IAAO,IAAI,kBAAkB,OAAO,EACnD;EAAC;EAAI;EAAkB;CAAO,EAC/B;AACF;;;;;;;;;;;;;;;;ACtCD,SAAgB,mBACdC,WACAC,cACe;CACf,MAAMC,aACJ,qBAAqBC,+BAA0B,iBAAiB,cAC5D,UAAU,UAAU,GACpB;CACN,MAAM,CAAC,OAAO,SAAS,GAAG,oBAAS,WAAW;AAE9C,sBAAU,MAAM;EACd,MAAM,eAAe,UAAU,UAAU,CAACC,QAAW,SAAS,IAAI,CAAC;AACnE,SAAO,MAAM,aAAa,aAAa;CACxC,GAAE,CAAC,SAAU,EAAC;AAEf,QAAO;AACR;AAKD,SAAS,OAAUC,GAAqC;AACtD,YAAW,MAAM,WACf,QAAO,GAAG;AAGZ,QAAO;AACR;;;;;;;;;;AA4BD,SAAgB,cACdC,YACAC,cACAC,qBACAC,MACe;AACf,YAAW,eAAe,eAAe,KACvC,OAAM,IAAIC,2BACR;CAIJ,MAAM,gBAAgB,kBAA6B,KAAK;CACxD,MAAM,iBAAiB,kBAAgB,MAAM;CAE7C,MAAM,iBAAiB,mBACrB,MAAM,YACN,CAAC,UAAW,SAAS,cAAc,OAAO,CAAC,UAAW,CAAE,EACzD;CAID,MAAM,CAAC,GAAG,iBAAiB,GAAG,oBAAiB,EAAE;CAEjD,MAAM,WAAW,kBACf,CAAC,MAAM;EACL,IAAIC;AACJ,MAAI,gBAAgB;GAClB,MAAM,MAAM,OAAO,eAAe,CAAC,UAAU,CAAC,UAAU;AACtD,mBAAe,UAAU;AACzB,wBAAoB;GACrB,EAAC;AAEF,OAAI,aAAa;EAClB;AAED,SAAO,qBAAqB;CAC7B,IAAG,CACL;AAED,sBAAU,MAAM;EACd,IAAIC,eAAoC;AACxC,MAAI,gBAAgB;AAClB,iBAAc,UAAU,OAAO,eAAe;AAC9C,kBAAe,cAAc,QAAQ,UAAU,CAAC,UAAU;AACxD,aAAS,UAAU;AACnB,qBAAiB,CAAC,SAAS,OAAO,EAAE;GACrC,EAAC;EACH;AAED,SAAO,MAAM,cAAc,aAAa;CACzC,GAAE,CAAC,cAAe,EAAC;AAEpB,KAAI,wBAAwB,eAAe,QACzC,OAAM,IAAI,MACR;AAIJ,QAAO,SAAS;AACjB;;;;;;AAOD,SAAgB,gBAAgBC,SAAiC;CAC/D,MAAM,GAAG,QAAQ,GAAG,oBAAS,EAAE;AAE/B,sBAAU,MAAM;EACd,MAAM,eAAe,QAAQ,UAAU,MAAM,QAAQ,CAAC,SAAS,OAAO,EAAE,CAAC;AACzE,SAAO,MAAM,aAAa,aAAa;CACxC,GAAE,CAAE,EAAC;AACP;AAED,MAAM,sCAAsB,IAAI;;;;;AAMhC,SAAgB,qBACdb,WACAC,cAIA;CACA,MAAM,SAAS,yBAA4C;CAC3D,MAAM,QAAQ,cAAc,WAAW,aAAa;CACpD,MAAM,UAAU,mBACd,MAAM,yBAA6B,MAAM,EACzC,CAAC,SAAU,EACZ;CACD,MAAM,WAAW,uBACf,CAACa,UAAqD;AACpD,yBACE,2BAAC,QAAQ;GAAgB;aAAQ,MAAM;IAA4B;CAEtE,GACD,CAAC,WAAW,KAAM,EACnB;AAED,KAAI,OAAO,YAAY,WAAW;AAChC,MAAI,OAAO,QACT,qBAAoB,OAAO,OAAO,QAAQ;AAG5C,SAAO,UAAU;AACjB,sBAAoB,IAAI,WAAW,QAAQ;CAC5C;AAED,QAAO;EACL;EACA;CACD;AACF;AAED,SAAgB,0BACdd,WACe;CACf,MAAM,UAAU,oBAAoB,IAAI,UAAU;AAElD,MAAK,QACH,OAAM,IAAIU,2BACR,CAAC,kEAAkE,CAAC;AAIxE,QAAO,sBAAW,QAAQ;AAC3B"}